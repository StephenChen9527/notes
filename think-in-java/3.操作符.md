### 3.操作符
##### 3.1更简单的打印语句
`System.out.println`

当使用一些静态方法的时候，直接通过类名调用，更简单的可以通过静态导入`static`进行导入，直接使用。
![静态导入](https://wx4.sinaimg.cn/large/005VwC5mly1g6hhu5f6q5j30hj07zglr.jpg "静态导入")

这样就可以当成是在使用自身成员变量、方法一样使用被导入的类的成员变量和方法。

##### 3.2事故听Java操作符
| 操作符 |                      释义                      |
|:------:|:----------------------------------------------:|
|  `+`   |          加法运算、字符串拼接（重载）          |
|  `-`   |                    减法运算                    |
|  `*`   |                    乘法运算                    |
|  `/`   |            除法运算（可能丢失精度）            |
|  `%`   |                   取余数操作                   |
|  `=`   |                    赋值操作                    |
|  `==`  | 判断是否相等（基本对象判断数值，对象判断地址） |
|  `!=`  |                  与 `==相反`                   |
|  `+=`  |              `i+=2;`表示 `i=i+2;`              |
|  `-=`  |                       -                        |
|  `*=`  |                       -                        |
|  `/=`  |                       -                        |

其中`+`操作可以使用与字符串，`String`中，实现为`+`的重载。

数值类可以与字符串相加，但是无法使用其他运算符号。

字符串与字符串只能使用，相加符号。

##### 3.3优先级
Java中的运算也存在于优先级，简单的算术表达式为`先乘除，后加减，先算括号里面的`。

##### 3.4赋值
赋值操作`X=Y`，就是`X`的值赋给`Y`，这里的`=`并不是我们数学中的`=`，常数无法在等号左边，左边永远是一个变量在接收。

这里的意义为，等号右边的变量的 值或者引用的对象，赋值给等号左边的变量。

当然，不相同的数据类型的变量是无法正常赋值的，例如`int`赋值给`String`（报错）。

数值类型的变量是可以互相赋值，但是需要进行类型转换，宽范围（long）转到窄范围（int），可能会造成数值丢失，但是窄类型（int）一定可以正常赋值给宽类型（long）。

```java
User user1=new User();
User user2=new User();

user2=user1;
```
像上图中的第三行，就为对象引用的赋值，最开始两个变量指向两个不同的对象实例（指向对象的变量存储的都是引用），经过赋值，`user1`对象的引用赋值给了`user2`，因此，到最后，`user1`和`user2`指向的是同一个对象（变量保存了相同的引用，指向的内存地址是相同的）。

无论通过`user1`还是`user2`,其实调用的效果是一样的，就可以认为王明有一个小名小做“小明”，无论是 叫大名还是小名，都是说的同一个人。

```java
public class Demo3 {

    static void f(Letter letter){
        letter.i=100;
    }
    public static void main(String[] args) {
        Letter letter=new Letter();
        letter.i=5;
        System.out.println("1.letter.i:"+letter.i);
        f(letter);
        System.out.println("2.letter.i:"+letter.i);
    }

}

class Letter{
    int i;
}

out:
1.letter.i:5
2.letter.i:100

```

可以从上面看出来，对象`letter`的`i`被修改了，这是因为方法传递的是对象的`引用`,而不是副本。

当参数为基本类型的时候，则会复制一份`值`去给方法，且在方法内无论怎么修改，都不会印象到传递方法的那个变量（String，也不会被修改，因为无论对String进行，什么操作，都只是新生成的一个String对象，并不会去修改原始String）。

##### 3.5算术操作符

算术表如之前所示。

整数之间的触发，会直接去掉小数点之后，而不是四舍五入。

书中在示例中提到了`Random`类，需要一个`种子`（用于随机数生成器的初始化值，随机数生成器对于特定的种子值，总是产生相同的随机数序列），如果不传，则种子为当前时间。

```java
  int i=10;
  int a=-i;
  int x=i* -a;
```
以上的都没有编译错误。但是第三行的`i*-a`还是很奇怪，因此最好还是加括号`int x=i * (-a);`用来消除歧义。

##### 3.6自动递增和递减

自动递增：`++`

自动递减：`--`

这两个都只能用到基本类型中，可以放到变量前，也可以放到变量后面，如：
```java
int i=10;
i++;
++i;
```
这两种情况稍微有一些差别。

主要在方法中提现:
```java
public class Demo3 {
    public static void main(String[] args) {
        int x=10;
        int y=10;
        sout(x++,++y);
    }

    static void sout(int x,int y){
        System.out.println("x:"+x);
        System.out.println("y:"+y);
    }
}

out:
x:10
y:11

```
可以看出，x加之前，被传入方法，y是加之后被传入方法。

##### 3.7关系操作符
关系操作符生成的是一个boolean结果。

| 符号 |    释义    |
|:----:|:----------:|
|  ==  |    等于    |
|  >=  | 大于或等于 |
|  <=  | 小于或等于 |
|  >   |    大于    |
|  <   |    小于    |
|  !=  |   不等于   |

数值的比较是最简单的。

对象的比较是不能使用`==`的，因为对象比较的是“引用地址”。

因为String的特殊性，因此，当有如下代码：
```java
    String str1="str1";
    String str2="str1";
    System.out.println(str1==str2);

    Integer i1=1; //129
    Integer i2=1; //129
    System.out.println(i1==i2);

```
这段代码是`true`，因为当直接等于的时候，字符串被存储在“静态块”,因此，两个变量引用的是同一个，当使用`new`关键字的时候，对象会被开辟两个新空间，结果会是`false`。


对于Integer对象，由于自动装箱，虽然是对象，但是Integer内部存在一个缓存。`-128  +127`。当使用缓存范围内，且非`new`关键字的时候，就是`true`，其他是`false`。

包装类也都存在一个缓存区间。

字符串如果想要比较的话，使用`equals`方法，其他对象想要比较则需要重写`equals`方法（默认的方法是比较“引用地址”）。

##### 3.8逻辑操作符
| 操作符 | 释义 |
|:------:|:----:|
|  `&&`  | 并且 |
|  `\|\|`  | 或者 |
|  `!`   |  非  |

逻辑操作符可以将多个关系操作符产生的结果连接起来。

逻辑操作符只可以用于布尔值。

在使用逻辑运算符的时候，可能遭遇“短路”，是源于JRE对运行时候的一种优化。

当使用`&&`的时候，表达式左边为`false`的时候，JRE并不会继续执行后面的逻辑。因为没有必要。

当使用`||`的时候，表达式左边为`true`的时候，JRE也不会继续执行后面的逻辑。

这就会造成一种现象，如果判断的是通过两个方法返回的逻辑值，且在方法体中将对象进行了修改，且判断后续代码会使用，请注意短路现象。 有可能后面的方法并不会执行。

```java
public class Demo4 {

    public static void main(String[] args) {
        System.out.println(test(1)&&test(4)&&test(10));
        System.out.println("------------------------------");
        System.out.println(test(10)&&test(4)&&test(1));
        System.out.println("------------------------------");
        System.out.println(test(1)||test(4)||test(10));
        System.out.println("------------------------------");
        System.out.println(test(10)||test(4)||test(1));
    }

    public static boolean test(int i){
        System.out.println("入参为:"+i);
        if (i<5){
            return false;
        }
        return true;
    }
}

out:
入参为:1
false
------------------------------
入参为:10
入参为:4
false
------------------------------
入参为:1
入参为:4
入参为:10
true
------------------------------
入参为:10
true
```
从上面可以看出，有些方法并没有执行，原因就在于短路，所以使用的时候，需要注意。

##### 3.9直接常量
数值常量后面有些需要标清类型。

|      情况       |                       释义                       |
|:---------------:|:------------------------------------------------:|
| `float f=1.1f`  | 需要再数值后面加`f`或者`F`表示是一个`float`类型  |
| `double d=1.1d` | 需要再数值后面加`d`或者`D`表示是一个`double`类型 |
| `long l=99999l` |  需要再数值后面加`l`或者`L`表示是一个`long`类型  |
|  `int i=0x2f`   |             开头为`0x`，表示为16进制             |
|  `int i=0711`   |          开头为`0`,后面`0-7`表示8进进制          |
| `int i=0b1111`  |             开头为`0b`，表示为2进制              |

当然也可以使用`Integer`类进行转换。这里就不详细描述了。

###### 指数计数
```java
    long l=41e21L;
```
表示41乘以10的21次方。

`e`前面是基数，`e`后面是10的次方数，与数学中的`e`并不相同。

##### 3.10按位操作符
按位操作符是用来操作“比特（bit）”，即二进制的。
