## 面经收集并且自己尝试回答

#### 美团

1. OSI模型
  - OSI分为7层：
    1. 应用层 主要使用各种应用协议：如HTTP协议、smtp、pop3等应用协议
    2. 表现层 主要将信息的语法语义以及他们的关联，加密解密，转换翻译等
    3. 会话层 不同机器上的用户之间以及建立管理会话
    4. 运输层 将数据分段、并保证这些数据段有效到达对端
    5. 网络层 主要使用TCP/IP  UDP等，
    6. 数据链路层 将原始比特流转换为逻辑传输线路
    7. 物理层 物理线路
2. ARP协议
  - ARP协议主要作用是为了保证数据的正确性，完成自动重传，由于数据是被分段传输，且每个数据段内都有编号，在接收端接受到某个数据段后，确认无误之后会发回确认。如果过了一段时间，接收端没有确认，发送端就自动再次发送
3. 输入 www.baidu.com之后的过程
  - 输入 网址之后，
    1. 浏览器会先查询本地浏览器的缓存
    2. 如果没有则去查找win中的hosts文件
    3. 然后去本机DNS缓存解析器，
    4. 去DNS服务器进行查询
4. TCP三次握手和四次挥手
  - 三次握手过程
      1. 客户端发出SYN，服务端接收到SYN
      2. 服务端发回SYN，并且附加ACK
      3. 客户端发送ACK，建立连接
  -
  - 四次挥手主要是为了服务器进入CLOSE_WAIT装状态，服务端发送完还没发送完的数据
5. 为什么三次握手
  - 三次挥手主要是为了建立可靠连接
    1. 第一次发送SYN，服务端接收到SYN，确认了自己正常接收，与客户端的正常发送
    2. 发回SYN与ACK，服务端确认自己正常发送，接收正常，客户端发送正常
    3. 客户端接收到SYN/ACK 并发回AKC 客户端确认自己接收正常，发送正常，服务端接收正常，发送正常
    可靠连接经过三次才能确认。

6. 网络拥塞控制

7. HTPP状态码
  1. 1XX 代表请求已被接受，需要继续处理
  2. 2XX 一般表示服务器正常响应，如200
  3. 3XX 一般表示服务器要求客户端重定向，302
  4. 4XX 一般表示客户端请求存在问题：404 资源不存在,400 参数不规范
  5. 5XX 一般表示服务器问题，无法正常处理请求 500 504
8. HTTP与HTTPS区别
  - HTTPS 是 HTTP 的安全版本，在HTTP的基础上加入了SSL/TLS协议，在网络层之上将数据进行加密


9. HTTPS 加密过程
步骤：
 1. 客户端要求与服务器建立SSL连接
 2. 服务器将证书发送给客户端
 3. 客户端与服务器协商加密等级
 4. 客户端使用证书中的公钥将会话秘钥加密，然后发送给服务端
 5. 服务端使用私钥解密
 6. 利用会话秘钥与客户端进行通信
10. GET和POST的区别
  GET 是简单请求协议，一般将参数放置URL后端，是QueryString形式去请求，长度有限制，只能传输ASCII，如果遇到中文需要转码
  POST 可以将参数放到request body中，最大能传输3G内容，可以传输中文
11. 线程的状态
  NEW：线程创建时候
  READY：就绪状态，就是线程除CPU之外的一切资源已经就绪，只等待CPU时间片轮的调度。
  RUNNING：运行状态，获得了CPU的执行权，
  WAITING：等待状态，当线程调用WAITING
  BLOCKING：阻塞状态，当线程因为IO或者其他操作阻塞时
  DEAD：死亡状态
12. 线程中断
  - 主要是interrupt方法， 当执行了interrupt方法，只是设置了中断标志，并不会中断，是否需要中断线程操作是要自己去逻辑实现的。

13. 线程创建方式
  - 继承 Thread
  - 实现 Runnable
  - 实现 Callable
14. Synchorized 作用域与原理
  - SYN的作用域一般都是确定的，如果关键字加载了方法中，那么就是整个方法，如果只是加载了代码块上，那么就是这个代码块
  - 原理就是每个对象的头部都有一个monitor锁，如果想获取锁就是获取对象的monitor标志
15. Syn与ReentrantLock的区别
  Syn是JDK层面实现的，是一个关键字，依赖于JDK，而ReentrantLock是在API层面的，主要是使用方法进行加、释放锁。
  都是可重入锁。
  ReentrantLock底层使用了大量的CAS操作，在1.6及以前，SYN性能不高，不过后来也是基于CAS操作。性能基本持平
16. ReentrantLock 支持打断？
17. 线程池的类型
  1. 单例线程池 只有一个线程---》队列是无界队列--》OOM
  2. 固定线程数的线程池  固定线程池 core=max --》队列也是无界的--》OOM
  3. 缓存的线程池 core=max =Integer.Max  -->OOM
  4. 调度线程池
18. JVM内存结构和作用
    JVM主要分为：
      1. 堆 ： 2个新生代，1个老年代，1 1 8 ，新生代的作用主要是生成对象，2个的作用主要是为了复制算法需要，老年代主要存放多次gc没有被回收的对象，
      2. 元空间：方法区，线程共享区，位于直接内存，受限于本机的内存大小，主要存放java类的类信息
      3. 虚拟机栈：线程私有区域，存放线程的工作信息，主要为栈帧，当调用方法时，会压入一个栈帧，栈帧上存储了方法局部表量表，入口信息，出口信息等
      4. 本地方法栈：与虚拟机栈类似，主要是调用本地方法时，存储的一些信息
      5. 程序计数器：为java运行指令，使得程序知道下一步需要做什么，完成控制流程，再cpu上线文中切换会保存当前运行状态，等再调度的时候，会重新加载上下文信息，继续执行。
19. 垃圾回收怎么识别垃圾：
  - 引用计数法，当对象被引用的时，计数器+1，当引用更改时候，计数器-1，当计数器为0的时候，视为无用对象，可被回收，不过存在循环引用的问题
  - 可达性分析，从一个gc roots 根节点出发，遍历所有可以访问的对象，当某些对象无法被访问的时候，就是一个无用对象，可被回收
   可以被认为是gc roots的对象：
    本地方法栈中引用的对象
    虚拟机栈中引用的对象
    方法区被引用的对象

    回收：主要有各种垃圾回收器进行回收
    主要算法：标记-复制，标记-清除，标记-复制-压缩
    垃圾回收器主要有：
    cms g1 parnew
20. 各分代用什么算法?
  新生代主要使用标记-复制。所以 新生代有2块，方便复制
  老年代主要使用标记-清除。
21. 遇到频繁Full GC怎么办？
  内存快照，分析dump文件，查看占用内存大的对象是什么，是不是因为没有及时消除引用而造成了内存泄漏。



  ## 蚂蚁金服

1. 项目
2. HTTP与HTTPS区别
3. Mysql索引相关东西，索引优化，什么时候走索引，什么时候不走索引
4. 根据项目聊加密，非对称加密，对称加密
5. kafka为什么吊 跟其他mq相比，需要
6. redis相关
7. 如何使项目更稳健，从前到后捋一遍
8. 数据库主从，主从复制是怎么实现的。
9. docker相关
10. 什么情况下频繁发生yonggc fullgc
11. sync
12. es
