 ### labuladong算法小抄

* https://github.com/labuladong/fucking-algorithm

#### 数据结构

基本的数据结构只有以下两种：
* 数组（顺序存储）：紧凑连续的内存，可以随机访问，通过索引快速找到对应元素。如果扩容，需要重新分配一块更大的空间，再复制数据；插入，删除则需要移动后面所有数据，以保持连续。
* 链表（链式存储）：内存中不连续，依靠当前位置的下一个指针引用下一个节点，不存在扩容移动、复制问题。但是内存不连续，不能随机访问，只能顺序访问。

其他数据结构
* 队列：双实现（先进先出）
* 栈：双实现（后进先出）
* 图：链表
* 散列表：数组（一般会数组+链表例如Java中的`HasaMap`）：通过hash函数把Key映射到大数组里面，解决hash冲突的方法：
  * 开放寻址：
    1. 线性探测：当前位置已经存在，往后+1，直到不发生冲突（只适合数组的长度>=总数）
    2. 再平方探测：当前位置已经存在，hash+1的平方，若冲突，hash-1的平方，若冲突hash+2的平方····，反复横跳
    3. 伪随机探测：当前位置已经存在，hash+随机值，直到没有冲突。
  * 链地址法：冲突的位置，向后拉出一个链表（HashMap底层就是这个）
  * 公共溢出区：建立公共溢出区，统一存放冲突数据
  * 再hash法：hash值再Hash，直到没有冲突（全凭运气？）
* 树：数组的实现就是堆，链表实现就是各种树：二叉搜索、AVL平衡树、红黑树、区间树、B树
* 堆：数组实现，是一个完全二叉树，不需要存储节点指针（大顶堆，小顶堆）

#### 各种数据结构基本操作
