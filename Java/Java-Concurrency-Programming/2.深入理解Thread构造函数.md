# 2.深入理解Thread构造函数
## 线程的命名
在构造线程的时候，可以为线程起一个特殊意义的名字。

默认：

![线程默认](https://tva2.sinaimg.cn/large/005VwC5mly1g89m775ma1j30dl04gq3s.jpg)

线程名称在默认情况下会是`Thread-index`这种命名方式。

自定义：

![自定义](https://tvax1.sinaimg.cn/large/005VwC5mly1g89m8tshbpj30gl03qmxz.jpg)

在这种情况下，可以在构造函数中指定线程名字。

修改线程名字：

线程名字只能在启动之前进行修改，启动之后则无法修改，使用`setName()`

## 线程的父子关系

![创建线程时的代码](https://tvax1.sinaimg.cn/large/005VwC5mly1g89mc4nnhdj30jc05kdho.jpg)

在创建线程的时候，最终都会执行到`init`方法。

在`Thread parent`中是获取当前线程，因此：
* 一个线程的创建肯定是另外一个线程完成的。（废话...）
* 被创建线程的父线程是创建它的线程

## Thread与ThreadGroup

Thread在构造的时候如果没有显式地指定一个ThreadGroup，那么子线程将被加入父线程所在的线程组。

* mian线程所在的ThreadGroup成为mian
* 构造一个线程的时候如果没有显式地指定ThreadGroup，那么它将会和父线程同属于一个ThreadGroup

## Thread与Runnable

`Thread`负责线程本身相关职责和控制，而`Runnable`则负责逻辑执行单元的部分。

## Thread与JVM虚拟机栈

`Thread`与`Stacksize`

![stacksize](https://tva2.sinaimg.cn/large/005VwC5mly1g89mrfp4oij30p10dzn7l.jpg)

这个段位有点高啊，stacksize是栈的大小？如果是栈的大小，那么设置大的话，递归调用越深很容易理解，因为递归就是入栈的操作，为什么线程数就少了呢？

书中的例子也只是说了递归的深度，没有说线程的数量。


`JVM内存结构`

JVM在执行Java程序的时候，会把对应的屋里内存划分成不同的内存区域：

![JVM内存结构](https://tva3.sinaimg.cn/large/005VwC5mly1g89n0zpoe7j309v06eq4j.jpg)

1.` 程序计数器`

在JVM中所起的作用就是用于存放当前线程接下来要执行的字节码指令、分支、循环、跳转、异常处理等信息。为了能够在CPU时间片轮转切换上下文之后顺利回到正确的执行位置，每条线程都需要具有一个独立的程序计数器。
2. Java虚拟机栈

Java虚拟机栈也是线程私有的，它的生命周期与线程相同，是在JVM运行时所创建的，在线程中，方法在执行的时候都会创建一个栈帧的数据结构，主要用于存放局部变量表、操作栈、动态链接、方法出口等信息。方法的调用对应着栈帧在虚拟栈中的压栈和弹栈过程。

![虚拟机栈](https://tvax1.sinaimg.cn/large/005VwC5mly1g89nc9iohnj30ls0bhdlp.jpg)

虚拟机栈大小可以通过 -xss 来配置，方法的调用是栈帧被亚茹和弹出的过程，同等的虚拟机栈如果局部变量表等占用内存小则可被亚茹的栈帧就多，反之就少。一般将栈帧内存的大小称为宽度，而栈帧的数量则被称为虚拟机栈的深度。

3. 本地方法栈

JNI，是Java可以调用C/C++程序的接口。网络通信、文件操作的底层都是JNI，JVM为本地方法所划分的内存区域更是本地方法栈。

4. 堆内存

堆内存是JVM中最大的一块内存区域，被所有的线程所共享，Java在运行期间创建的对象几乎都被放在该内存区域，该内存也是垃圾回收的主要区域。

堆内存一般会被细分为新生代和老年代，更细致的划分为Eden区、From Survior区和To Survivor区域。

![堆区的划分](https://tva2.sinaimg.cn/large/005VwC5mly1g89njsmnisj30a306075v.jpg)

5. 方法区

方法区是可以被多个线程所共享的内存区域，主要保存已经加载的类信息、常亮、静态变量、即时编译器（JIT Just In Time）编译后的代码等数据。在Java虚拟规范中，将方法区划分为堆内存的一个逻辑分区，但是还是经常被称为“非堆”，有时候也被称为“持久代”。

方法区还会被细化分为 持久代 和 代码缓存区，代码缓存区主要用于存储编译后的本地代码以及JIT编译器生成的代码。

6. Java8元空间

在JDK1.8版本中，持久代内存趋于被Meta Space取而代之了，元空间同样是堆内存的一部分，JVM为每个类加载器分配一块内存列表，进行线性分配，块的大小取决于类加载器的类型，sun/反射/代理对应的类加载器块会小一些。

7. Thread与虚拟机栈

虚拟机栈内存划分的大小将直接决定在一个JVM进程中可以创建多少个线程。

堆内存不变，栈内存变大，可创建的线程越少。

栈是线程独享的，每个线程都会占有指定的内存大小，粗略的可以认为Java进程的内存为：`堆内存+线程数量*栈内存`

堆内存作为影响进程内存的技术，它的增大对线程数量的影响也是反比关系，但是并没有像栈内存那么明显。

线程数量=(最大地址空间-JVM堆内存-系统保留内存)/栈大小

## 守护线程
首部线程一类是比较特殊的线程，一般用于处理一些后台的工作，比如JDK的垃圾回收线程。

设置守护线程的方法很简单，调用`setDaemon`方法即可，true代表守护线程，false代表正常线程，子线程默认与父线程一致。

守护线程经常用作于执行一些后台任务。

## 总结
主要是Thread的构造函数，线程数量与栈帧大小关系，JVM内存关系等。

守护线程。
