# 9.类的加载过程
ClassLoader的主要职责就是负责加载各种class文件到JVM中，ClassLoader是一个抽象的class，给定一个class的二进制文件名，ClassLoader会尝试加载并且在JVM中生成构成这个类的各个数据结构，然后使其分布在JVM对应的内存中。

## 类的加载过程简介

类的加载过程一般分为三个比较大的阶段，分别是加载阶段、连接阶段和初始化阶段。
1. 加载阶段：主要负责查找并加载类的二进制数据文件，其实就是class文件
2. 连接阶段：连接阶段所做的工作比较多，细分为以下三个阶段：
    * 验证：确保类文件的正确性，比如class的版本，class文件的魔术因子是否正确。
    * 准备：为类的静态变量分配内存，并且为其初始化默认值
    * 解析：把类中的符号引用转换为字节引用
3. 初始化阶段： 为类的静态变量赋予正确的初始值（代码编写阶段给定的值）。

类的加载方式是一个延迟加载，懒加载，只有在首次使用某类的时候，才会被初始化，在同一个运行时包下，一个Class只会被初始化一次。

## 类的主动使用和被动使用
随着JIT技术越来越成熟，JVM运行期间的编译也越来越智能，不排除JVM在运行期间提前预判并且初始化某个类。

JVM同时规范了以下主动使用的场景：

1. 通过new关键字会导致类的初始化
2. 访问类的静态变量
3. 访问类的静态方法
4. 对某个类进行反射操作
5. 初始化子类会导致父类的初始化
6. 启动类

以下为被动使用，不会导致类的加载和初始化

1. 构造某个类的数组时并不会导致该类的初始化
2. 引用类的静态常量(final)不会导致类的初始化，如果值需要计算，则会导致类的初始化

## 类的加载过程详解

#### 1  加载

类的加载就是将class文件中的二进制数据读取到内存中，然后将该字节流所代表的静态存储结构转换为方法区中运行时的数据结构，并且在堆内存中生成一个该类的java.lang.Class对象，作为访问方法区数据结构的入口

![加载后](https://tvax4.sinaimg.cn/large/005VwC5mly1g8qh3ts4p1j30q60b1n2z.jpg)

类加载的最终产物就是堆内存的class对象，对于同一个ClassLoader来说，不管某个类被加载了多少次，对应到堆内存的class对象始终是同一个。

虚拟机规范指出了类的加载是通过一个全限定名来获取二进制数据流，但是并没有限定必须通过某个方式去获得，比如常见的class二进制文件，除此之外还会有如下几种形式。

* 运行时动态生成:ASM、java.lang.Proxy
* 通过网络获取：RMI
* 通过读取zip文件获得类的二进制字节流：jar，war（jar，war使用的都是zip同样的压缩算法）
* 将类的二进制数据存储在数据库的BLOB字段中
* 运行时生成class文件，并且动态加载。

![注意](https://tva2.sinaimg.cn/large/005VwC5mly1g8qhf9ozn3j30wz07e0zy.jpg)

#### 2  连接

连接阶段分为三个小的过程：验证、准备、解析

1. 验证：

  1. 验证文件格式主要是确保class文件的字节流所包含的内容符合当前JVM的规范，并且不会出现危害JVM自身安全的代码，如果不符合要求，则抛出VerifyError这样的异常或者子异常，主要验证信息：
     * 魔术因子：该因子决定了这个文件到底是什么类型，class文件的魔术因子是0XCAFEBABE
     * 主次版本号：查看当前class文件版本是否符合当前JDK锁处理的范围
     * class的MD5指纹
     * 常量池中的常量是否存在不被支持的变量类型
     * 指向常量中的引用是否指到了不存在的常量或者该常量的类型不被支持
     * 其他信息

  2. 元数据验证：元数据验证是对class的字节流进行语义分析，确保class字节流符合JVM规范的要求：
     * 检查这个类是否存在父类，是否实现了某个接口，这些父类和接口是否合法，或者是否真实存在。
     * 检查该类是否继承了被final修饰的类，被final修饰的类是不允许被继承并且其中的方法是不允许被override的。
     * 检查该类是否为抽象类，如果不是抽象类，那么它是否实现了父类的抽象方法或者接口中的所有方法
     * 检查这些方法重载的合法性，比如相同的方法和名称、相同的参数但是返回类型不相同，这些都是不被允许的
     * 其他语义验证

  3. 字节码验证：当经历过了文件格式和元数据的语义分析过程之后，还要对字节码进一步验证，主要验证的是控制流程：
     * 保证当前线程的程序计数器中的指令不会跳转到不合法的字节码指令中去。
     * 保证类型的转换是合法的
     * 保证任意时刻，虚拟机栈中的操作栈类型与操作指令代码都能正确地被执行。
     * 其他验证
  4. 符号引用验证：主要作用就是验证符号引用转换为直接引用的合法性。

     * 通过符号引用描述的字符串全限定名称是否能够顺利地找到相关的类。
     * 符号引用中的类、字段、方法，是否对当前类可见，比如不能访问引用类的私有方法
     * 其他

2. 准备

当一个class的字节流通过了所有的验证过程之后，就开始为该对象的类变量（静态变量），分配内存并且设置初始值了，类变量的内存会被分配到方法区中，不同于实例变量的会被分配到堆内存中。

![初始值](https://tvax2.sinaimg.cn/large/005VwC5mly1g8qrmn68yoj30c50avjti.jpg)


3. 解析

![解析](https://tva1.sinaimg.cn/large/005VwC5mly1g8qs695lgnj30vj071n3q.jpg)

    1. 类接口解析
        *
    2.
