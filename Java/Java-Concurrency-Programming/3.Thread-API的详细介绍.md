# 3.Thread API的详细介绍
## 线程sleep
```java
public static void sleep(long millis) throws ....;
public static void sleep(long millis,int nanos) throws ....
```
该方法使线程进入指定毫秒数的休眠，暂停执行，虽然给定了一个休眠时间，但是最终要以系统的定时器和调度器的精度为准，休眠有一个非常重要的特性，那就是其不会放弃锁的所有权。

使用TimeUnit代替Thread.sleep

## 线程yield

yield方法属于一种启发式的方法， 其会提醒调度器我愿意放弃当前CPU资源，如果CPU的资源不紧张，则会忽略这种提醒。（ps，之前记得学的都是放弃CPU，并没有说CPU会忽略。。。感觉还是有点差别的）

yield方法会使线程从`RUNNING`状态切换到`RUNNABLE`状态，一般这个方法不太常用。

yield和sleep：
* sleep会导致当前线程暂停指定时间，没有CPU时间片的消耗
* yield只是对CPU调度器的一个提示，如果CPU调度器没有忽略这个提示，他会导致线程上线文切换
* sleep会使线程短暂block，会在给定的时间内释放CPU资源
* yield会使RUNNING状态的Thread进入RUNNABLE状态
* sleep机会百分之百地完成了给定时间的休眠，而yield的提示并不能一定担保
* 一个线程sleep另一个线程调用interrupt会捕获到中断信号，而yield则不会

## 设置线程优先级
```java
public final void setPriority(int newPriority);
public final int getPriority();
```
* 对于root用户，它会暗示操作系统你想要设置的优先级别，否则它会被忽略
* 如果CPU比较忙，优先级高的可能会获得更多CPU时间片，闲时则几乎无作用

设置优先级并不能保证优先级高的一定先执行！这个跟CPU的调度有关。

线程优先级的范围为1-10。且如果线程的优先级大于线程所在的组的优先级，那么指定的优先级将会失效，取而代之的是组的最大优先级。

执行的优先顺序并不能依靠线程优先级来保证，如果没有指定，则使用默认的等级：5,子线程默认与父线程保持一致。

ps：这个玩意。。。很少用，反正是没见用过。

## 获取线程ID
```java
public long getId();
```
获取线程唯一ID，线程的ID在整个JVM进程中都会是唯一的。

## 获取当前线程
```java
public static Thread currentThread();
```
这个经常使用，返回当前线程的引用。

## 设置线程上下文加类加载器

* public ClassLoder getContextClassLoader()获取线程上下文的类加载器，简单来说就是这个线程是有哪个类加载器加载的，默认下雨父线程同样的类加载器。
* public void setContextClassLoader(ClassLoader cl)设置该线程的类加载器。

## 线程interrupt

```java
public void interrupt();
public static boolean interrupted();
public boolean isInterrupted();
```
如果某线程调用如下方法进入阻塞状态，而调用当前线程的interrupt方法，就可以打断阻塞：
* wait
* sleep
* join
* InterruptibleChannel的io操作
* Selector的wakeup方法
* 其他

上述方法都会使当前线程进入阻塞状态，如果另外一个线程调用被阻塞线程的interrupt方法，则会打断这种阻塞，因此这种方法有时会被成为可中断方法。

ps：打断的并不是该线程的生命周期，而是打断了当前线程的阻塞状态。

例子可以看书本中的。

![interrupt细节](https://tva3.sinaimg.cn/large/005VwC5mly1g8f3395sapj30z206rdmn.jpg)
