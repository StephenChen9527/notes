# 10.JVM类加载器
对任意一个class，都需要由加载它的类加载器和这个类本身确立其在JVM中的唯一性。


## JVM内置三大类加载器

![双亲委派模型](https://tvax1.sinaimg.cn/large/005VwC5mly1g8ufycny39j30j20av41i.jpg)

#### 根类加载器
Bootstrap类加载器，该类加载器是最顶层的加载器，其没有任何父加载器，由C++编写， 主要负责虚拟机核心类库的加载，java.lang包都是由根加载器所加载的，可以通过`-Xbootclasspath` 来指定根加载器的路径。

JVM参数中的`sun.boot.class.path`

#### 扩展类加载器

扩展类加载器的父加载器是根加载器，它主要用于加载`JAVA_HOME`下的`jre/lb/ext`子目录里面的类库。扩展类加载器是由纯Java语言实现的，它是`java.lang.URLClassLoader`的子类，它的完整类名是`sun.misc.Launcher#ExtClassLoader`

JVM参数中的`java.ext.dirs`

#### 系统类加载器介绍

系统类加载器是一种常见的类加载器，负责加载classpath下的类库资源：第三方jar包。

系统类加载器的父类是扩展类加载器，同时它也是自定义类加载器的默认父加载器通过`-classpath`或者`-cp`指定，同时也可以通过系统属性`java.class.path`获取。



## 自定义类加载器

所有的自定义类加载器都是`ClassLoader`的直接子类或者间接子类，`java.lang.ClassLoader`是一个抽象类，需要继承并且实现`findClass`方法

书本中的例子主要是继承`java.lang.ClassLoader`，重写了`findClass`方法，将文件通过绝对路径读取成二进制，然后通过调用`defineClass`方法，进行加载到JVM内存中。

看完他写的代码，唯一的感觉就是，自己对Java的类库了解真的太少了，感觉都没见过，更没有用过。。。尴尬。

#### 双亲委托机制详细介绍

双亲委托机制，有时候也称为父委托机制，当一个类加载器被调用了loadClass知乎，它并不会将其直接加载，而是先交给当前类加载器的父加载器尝试加载，直到最顶层的父加载器，然后再依次向下加载。

![双亲委托机制](https://tva4.sinaimg.cn/large/005VwC5mly1g8vj3e72nlj30jw09cadk.jpg)

查看`java.lang.ClassLoader`的源码：

1. 从当前类加载器的已加载类缓存中根据类的全路径名查询是否存在该类，如果存在在，则直接返回
2. 如果当前类加载器存在父类加载器，则调用父类加载器的loadClass(name,false)方法对其进行加载
3. 如果当前类加载器不存在父类加载器，则直接调用根类加载器对该类进行加载
4. 如果当前类的所有父类加载器都没有成功加载class，则尝试调用当前类加载器的findClass方法对其进行加载，做法就是我们自定义加载器需要重写的方法。
5. 最后如果类被成功加载，则做一些性能数据的统计。
6. 由于loadClass指定了resolve为false，所以不会进行连接阶段的继续执行，而这也就解释了为什么通过类加载器加载类不会导致该类的初始化。


`https://www.cnblogs.com/noteless/p/9575448.html` blog ，看了源代码，其实还是运行步骤有点不是很清晰。

在App加载器中，存在这样子的代码：

![App加载器](https://tvax4.sinaimg.cn/large/005VwC5mly1g8vlko66bqj30x20jyjsh.jpg)

其中this.ucp.knowToNotExist(var1)这个方法也是用来判断该类有没有被加载过。

在`ClassLoader`中的LoadClass源码：

```java
protected Class<?> loadClass(String name, boolean resolve)
     throws ClassNotFoundException{
     synchronized (getClassLoadingLock(name)) {
         // First, check if the class has already been loaded
         Class<?> c = findLoadedClass(name);
         if (c == null) {
             long t0 = System.nanoTime();
             try {
                 if (parent != null) {
                     c = parent.loadClass(name, false);
                 } else {
                     c = findBootstrapClassOrNull(name);
                 }
             } catch (ClassNotFoundException e) {
                 // ClassNotFoundException thrown if class not found
                 // from the non-null parent class loader
             }

             if (c == null) {
                 // If still not found, then invoke findClass in order
                 // to find the class.
                 long t1 = System.nanoTime();
                 c = findClass(name);

                 // this is the defining class loader; record the stats
                 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                 sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                 sun.misc.PerfCounter.getFindClasses().increment();
             }
         }
         if (resolve) {
             resolveClass(c);
         }
         return c;
     }
 }

```

发现先判断的是否存在父类加载器，如果有，就调用父类的加载器，如果没有就调用`BootstrarpClassOrNull`方法。


https://www.baidu.com/s?wd=this.ucp.knownToNotExist(var1)&rsv_spt=1&rsv_iqid=0x91a8fe9b00140f71&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_dl=ib&rsv_sug3=3&rsv_n=2&rsv_sug2=0&inputT=635&rsv_sug4=456339



https://blog.csdn.net/qq_30993595/article/details/97165823

https://blog.csdn.net/u010013687/article/details/68921163

https://www.baidu.com/s?wd=c%20%3D%20findBootstrapClassOrNull(name)&rsv_spt=1&rsv_iqid=0xbd0f82d40019a5d9&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_dl=ib&rsv_n=2&rsv_sug3=1&rsv_sug2=0&inputT=220&rsv_sug4=221



https://blog.csdn.net/l841017122/article/details/51453469

暂时记录一下，感觉没有走通逻辑很难受，没看到哪里defineClass的。。。明天继续看
