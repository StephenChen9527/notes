# 深入volatile关键字

## 并发编程的三个重要特性

#### 原子性

所谓原子性是指在一次的操作或者多次操作中，要么所有的操作全部得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。

#### 可见性

当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。

#### 有序性

指程序在执行过程中的先后顺序，由于Java在编译器以及运行期的优化，导致代码的执行顺序未必就是开发者编写代码时的顺序。

指令重排序：处理器为了提高程序的运行效率，可能会对输入的代买指令做一定的优化，它不会百分之百的保证代码的执行顺序严格按照编写代码中的顺序来进行，但是它会保证程序的最终运算结果是编码时所期望的那样。

![多线程下指令重排序](https://tvax3.sinaimg.cn/large/005VwC5mly1g9ceuny4zqj30x00mhk6g.jpg)

如果上面的if里面的代码发生了重排序，那么在还没有初始化的时候，先设置成了true，然后其他线程判断了if，直接返回了context是null。

## JMM如何保证三大特性

JVM采用的内存模型的机制来屏蔽各个平台和操作系统之间内存访问的差异，以实现让Java程序在各种平台下达到一致的内存访问效果。

Java的内存模型规定了所有的变量都是存在于主内存(RAM)当中的，而每个线程都有自己的工作内存或者本地内存，线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接对主内存进行操作，而且每一个线程都不能访问其他线程的工作内存或者本地内存。

#### JMM与原子性
基本类型的变量读取赋值操作都是原子性的，对引用类型的变量读取和赋值的操作也都是原子性的。

1. X=10：原子操作。

![X=10](https://tva2.sinaimg.cn/large/005VwC5mly1g9cknnw6urj30vv04rdk8.jpg)

2. Y=X：非原子操作。

![Y=X](https://tvax4.sinaimg.cn/large/005VwC5mly1g9ckrs4yclj30xb06179i.jpg)

3. y++，非原子
4. z=z+1，非原子

其中1、2的区别在于1是直接写入，2是有一个读取的操作？

结论：
* 多个原子性的操作在一起就不再是原子性操作
* 简单的读取与赋值操作是原子性，将一个变量赋值给另外一个变量操作就不是原子性了
* JMM只保证了基本的读取和赋值的原子操作性，其他的均不保证，如果想要使得某些代码片段具备原子性，需要使用关键字synchronized，或者JUC中的lock

ps：volatile关键字不具备保证原子性语义。

#### JMM与可见性

在多线程的环境下，如果某个线程首次读取共享变量，则首先到主内存中获取该变量，然后存入工作内存中，以后只需要在共工作内存中读取该变量即可。

如果执行了修改操作，同样也是先修改工作内存中的副本，然后再刷新到主内存中，至于什么时候最新的值会被刷新到主内存中是不太确定的。

Java提供了以下三种方式保证可见性：

* 关键字volatile

![关键字volatile](https://tvax3.sinaimg.cn/large/005VwC5mly1g9cl58a4i2j30v305uafn.jpg)

* 关键字synchronized

![关键字synchronized](https://tva4.sinaimg.cn/large/005VwC5mly1g9cl627pq1j30tv03a0vm.jpg)

* JUC包的Lock

![JUC包的Lock](https://tva3.sinaimg.cn/large/005VwC5mly1g9cl6ljrrkj30ti03pwho.jpg)

其中1的感觉有点像缓存一致性的实现，修改了当前的值，就会通知其他存有副本变量的线程重新充缓存中加载最新的值。

2的就是执行完代码之后，将值必定刷新到主内存中，其他线程再拿到这个值的时候，就可以拿到最新的了。

#### JMM与有序性

java提供了三种保证有序性的方式：
1. volatile关键字
2. synchronized关键字
3. 显式锁Lock

后两者是采用同步机制。

java的内存模型具备一些天生的有序性规则，不需要任何同步手段就能保证有序性，这个规则被称为Happens-before原则。
