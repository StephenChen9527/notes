# 深入volatile关键字

## 并发编程的三个重要特性

#### 原子性

所谓原子性是指在一次的操作或者多次操作中，要么所有的操作全部得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。

#### 可见性

当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。

#### 有序性

指程序在执行过程中的先后顺序，由于Java在编译器以及运行期的优化，导致代码的执行顺序未必就是开发者编写代码时的顺序。

指令重排序：处理器为了提高程序的运行效率，可能会对输入的代买指令做一定的优化，它不会百分之百的保证代码的执行顺序严格按照编写代码中的顺序来进行，但是它会保证程序的最终运算结果是编码时所期望的那样。

![多线程下指令重排序](https://tvax3.sinaimg.cn/large/005VwC5mly1g9ceuny4zqj30x00mhk6g.jpg)

如果上面的if里面的代码发生了重排序，那么在还没有初始化的时候，先设置成了true，然后其他线程判断了if，直接返回了context是null。

## JMM如何保证三大特性

JVM采用的内存模型的机制来屏蔽各个平台和操作系统之间内存访问的差异，以实现让Java程序在各种平台下达到一致的内存访问效果。

Java的内存模型规定了所有的变量都是存在于主内存(RAM)当中的，而每个线程都有自己的工作内存或者本地内存，线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接对主内存进行操作，而且每一个线程都不能访问其他线程的工作内存或者本地内存。

#### JMM与原子性
基本类型的变量读取赋值操作都是原子性的，对引用类型的变量读取和赋值的操作也都是原子性的。

1. X=10：原子操作。

![X=10](https://tva2.sinaimg.cn/large/005VwC5mly1g9cknnw6urj30vv04rdk8.jpg)

2. Y=X：非原子操作。

![Y=X](https://tvax4.sinaimg.cn/large/005VwC5mly1g9ckrs4yclj30xb06179i.jpg)

3. y++，非原子
4. z=z+1，非原子

其中1、2的区别在于1是直接写入，2是有一个读取的操作？

结论：
* 多个原子性的操作在一起就不再是原子性操作
* 简单的读取与赋值操作是原子性，将一个变量赋值给另外一个变量操作就不是原子性了
* JMM只保证了基本的读取和赋值的原子操作性，其他的均不保证，如果想要使得某些代码片段具备原子性，需要使用关键字synchronized，或者JUC中的lock

ps：volatile关键字不具备保证原子性语义。

#### JMM与可见性

在多线程的环境下，如果某个线程首次读取共享变量，则首先到主内存中获取该变量，然后存入工作内存中，以后只需要在共工作内存中读取该变量即可。

如果执行了修改操作，同样也是先修改工作内存中的副本，然后再刷新到主内存中，至于什么时候最新的值会被刷新到主内存中是不太确定的。

Java提供了以下三种方式保证可见性：

* 关键字volatile

![关键字volatile](https://tvax3.sinaimg.cn/large/005VwC5mly1g9cl58a4i2j30v305uafn.jpg)

* 关键字synchronized

![关键字synchronized](https://tva4.sinaimg.cn/large/005VwC5mly1g9cl627pq1j30tv03a0vm.jpg)

* JUC包的Lock

![JUC包的Lock](https://tva3.sinaimg.cn/large/005VwC5mly1g9cl6ljrrkj30ti03pwho.jpg)

其中1的感觉有点像缓存一致性的实现，修改了当前的值，就会通知其他存有副本变量的线程重新充缓存中加载最新的值。

2的就是执行完代码之后，将值必定刷新到主内存中，其他线程再拿到这个值的时候，就可以拿到最新的了。

#### JMM与有序性

java提供了三种保证有序性的方式：
1. volatile关键字
2. synchronized关键字
3. 显式锁Lock

后两者是采用同步机制。

java的内存模型具备一些天生的有序性规则，不需要任何同步手段就能保证有序性，这个规则被称为Happens-before原则。

* 程序次序规则：在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生于编写在前面的操作之后
* 锁定规则：一个unlock操作要先行发生于对同一个锁的lock操作
* volatile变量规则：对于一个变量的写操作要遭遇对这个变量之后的读操作

![volatile变量规则](https://tva1.sinaimg.cn/large/005VwC5mly1g9drm74d16j30vw03hwhf.jpg)
* 传递规则：如果操作A先与B，而操作B又先与操作C，则可以得出操作A肯定要先与操作C
* 线程启动规则：Thread对象的start方法先发生于对该线程的任何动作，这也是我们在第一部分中讲过的。只有start之后线程才能真正的运行，否则Thread也只是一个对象而已
* 线程中断规则：对县城执行interrupt方法肯定要优先于捕捉到中断信号，意思是指如果线程接收到了中断信号，那么在此之前势必要有interrupt()（这感觉像个废话。。。。）。
* 线程的终结规则：线程中所有的操作都要先与发生于线程的终止检测，意思是指：线程的任务执行、逻辑单元执行肯定是要发生于线程死亡之前（run方法里面的内容吧？感觉也是个废话）
* 对象终结规则：一个对象初始化的完成先于发生于finalize()方法之前。（。。。。。。。。。）

## volatile关键字深入解析

被volatile修饰的实例变量或者类变量具备如下两次语义
* 保证了不同线程之间对共享变量操作时的可见性，当一个线程修改了变量，另一个线程会立即看到最新的值。
* 禁止指令重排序

![可见性](https://tva3.sinaimg.cn/large/005VwC5mly1g9ds562u5lj30vl0gigxb.jpg)

保证的可见性应该是使用缓存一致性去实现的...

![禁止重拍](https://tvax3.sinaimg.cn/large/005VwC5mly1g9ds7lgy67j30k50fewi8.jpg)

禁止重排，但是无依赖关系的还是可以重拍的。（我认为依赖关系，是使用到了z，比如第二个例子，在一个方法里面，则禁止这个方法进行重拍，也能理解，第一个，应该也是在一个方法内，x y的定义无所谓，但是到了z定义的时候， x y必定是定义好的，且没有执行自增与自减操作。）

![不保证原子性](https://tvax4.sinaimg.cn/large/005VwC5mly1g9dsk733zdj30tl03sgn1.jpg)

我理解是：volatile虽然说修改完之后，可以让其他线程的缓存失效，然后重读最新值，猛然一读感觉像个乐观锁？但是仍然无法完全避免重复修改：

![不保证原子性](https://tvax1.sinaimg.cn/large/005VwC5mly1g9dsne91nwj30so0d0ajp.jpg)

时间片轮转分的很好，刚好两个“同时”刷新了主内存。

#### volatile的原理和实现机制

被volatile修饰的变量存在于一个“lock;”的前缀。。。。源码看不懂

“lock;”前缀实际上相当于是一个内存屏障，该内存屏障会为指令的执行提供以下几个保障：
* 确保指令重排序时不会将后面的代码重拍到内存屏障之前
* 确保指令重排序时不会将前面的代码重拍到内存屏障之后
* 确保执行到内存屏障修饰的指令时前面的代码全部执行完成（啊咧？第2条？）
* 强制将线程工作内存中的值的修改刷新到主内存中
* 如果是写操作，则会导致其他线程工作内存（CPU Cache）中的缓存失效（缓存一致性）

#### volatile的使用场景

* 开关控制利用可见性特点
* 状态标记利用顺序性特点
* 单例中的双检查利用顺序性

#### volatile和synchronized

1. 使用上的区别：
  * volat只能用于修饰实例变量或者类变量，不能修饰方法以及方法参数、局部变量、常量。
  * synchronized关键字不能用于对变量的修饰，只能修饰方法或者语句块
2. 原子性的保证
  * volatile不保证
  * synchronized是一种排他机制，同步的代码块无法被打断，因此是原子性的
3. 可见性的保证
  * 两者都保证，但是实现不一样
  * synchronized借助JVM指令monitor enter和monitor eixt对通过排他方式使得同步代码串行化，在exit时共享资源都会被刷新到主内存中
  * volatile使用机器指令“lock;”的方式，强迫其他线程的缓存失效
4. 有序性的保证
  * volatile保证有序性，通过禁止指令重排
  * synchronize也是有序性，通过程序串行来执行，内部的指令还是可以重排的。
5. 其他
  * volatile不会阻塞线程
  * synchronized会阻塞线程

## 总结

讲了三大特性：原子性、可见性、顺序性。JMM与这三个特性的关系，深入讲了volatile。感觉源码没看懂，但是给的java例子大概了解到了volatile的特性。

最后总结了synchronized和volatile的异同。
