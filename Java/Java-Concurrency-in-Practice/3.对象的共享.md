# 3. 对象的共享

## 可见性
通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是不可能的事情。

在书本中的程序清单3-1中，试了几次并没有发现这种情况。。。

`https://www.iteye.com/problems/48582lz` 来自10年的疑问。。。想着是JDK版本做了优化，但是又觉得这个很奇怪。

还有人说这种几率很小。。。但是总觉的这种作为例子很难受啊，效果真的太不明显了。。。我记得之前在学这个字段的时候，确实有个例子来着。

原文中也只是说可能。。。。谁知道这个概率多大呢。。。

![程序清单3-1](https://tvax1.sinaimg.cn/large/005VwC5mly1g87b7ngbwwj30p20b8gmt.jpg)

>NoVisibility可能会持续循环下去，因为读线程可能永远看不到ready的值。一种更奇怪的现象是，NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入的numbe的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以很明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。

>ps：2019-10-30 看了另外一本书，java并发编程详解，里面有段类似的代码，但是没有`Thread.yield()`这个玩意，是能无限循环的，其他线程将信号量改写了，也一直循环。无论是成员变量还是类变量，都试了。但是发现如果将循环体内加入这个代码就不会无限循环了。这个方法主要是线程提醒CPU，自愿放弃CPU资源，重新进入RUNNABLE状态，类似于重新参与竞争，书中说CPU资源比较闲的时候，就会忽略，但是在这感觉并没有忽略，而是确实放弃了CPU的资源。在放弃之后，CPU再次调度到该线程，那么信号量也会被重新刷新到自己的线程空间内存中。这是我自己的一点看法。

原文如是说，`可能`。。。。。也有可能会输出0。。。。不过这个例子说的就是JVM的一种重排序，暂时先这样吧，等后面是否能回来填坑。

在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

`失效数据`：当读线程查看ready变量时，可能得到的是一个已经失效的值。

![代码示例](https://tvax2.sinaimg.cn/large/005VwC5mly1g87bj1rlq4j30ga03zglw.jpg)

当两个线程，其中一个线程调用了set，另外一个调用了get，那么get可能会看到更新后的，也可能看到更新钱的值。

`非原子的64为操作系统`

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值，这种安全性保证也被称为最低安全性。

这个最低安全性适用于绝大多数变量，但是存在一个例外：非`volatile`类型的64位数值变量（double和long）。

Java内存模型要求，变量的读取操作和写入操作必须是原子操作，但是对于非`volatile`类型的`long`和`double`变量，JVM允许将64位的读操作和写操作分解为两个32位的操作。当读取一个非`volatile`类型的`long`变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会被读取到某个值的高32位和另一个值的低32位。
