# 2.线程安全性
“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。

一个对象是否需要是线程安全的，取决于它是否被多个线程访问。

当多个线程访问某个状态变量并且其中一个线程执行写入操作时，必须采用用同步机制来协同这些线程对变量的访问。

Java中的主要同步机制是关键字`synchronized`，它提供了一种独占锁的加锁方式，但“同步”这个属于还包括`volatile`类型的变量，显式锁以及原子变量。


如果当多个线程访问同一个可变的`状态变量`时，没有使用合适的同步，那么程序就会可能出现错误。有三种方式可以修复这个问题：
1. 不再线程间共享该状态变量
2. 将该状态变量修改为不可变的变量
3. 在访问状态变量时使用同步

当设计线程安全的类时，良好的面向对象技术、不可修改性，以及明晰的不可变性规范都能起到一定帮助作用。

## 什么是线程安全性
在线程安全性的定义中，最核心的概念就是正确性：`某个类与其规范完全一致。`

当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类时线程安全的。

>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要额外的同步或协同，这个类都能表现出正常的行为，那么就称这个类时线程安全的。

如果正确地实现了某个对象，那么在任何操作中（包括调用对象的公有方法或者对其公有域进行读/写操作）都不会违背不变性条件或后验条件。

在线程安全类的对象实例上执行的任何串行或并行操作都不会使对象处于无效状态。

![不变性与后验条件](https://tva3.sinaimg.cn/large/005VwC5mly1g865wzujvaj30pa061tdh.jpg)

无状态的：
>既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。

`无状态对象一定是线程安全的`

大多数的`Servlet`都是无状态的，从而极大地降低了在实现`Servlet`线程安全性时的复杂性。

## 原子性
代码：

![计数器示例](https://tva3.sinaimg.cn/large/005VwC5mly1g866beqfnoj30lb07r75a.jpg)

`++value`包含了三个操作：`读取-修改-写入`的操作序列，并且其结果状态依赖于之前的状态。

如果该计数器被用来生成数值被用来生成数值序列或者唯一的对象标识符，那么多次调用中返回相同值将会导致严重的数据完整性问题，在并发编程中，这种由于不恰当执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞争条件。

最常见的竞争条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作。

`延迟初始化`

延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同事要确保只被初始化一次。

![延迟初始化](https://tva1.sinaimg.cn/large/005VwC5mly1g86tq43oe2j30pj083ab7.jpg)

如果多个线程同时调用这个方法， 进行判断的时候，都为空，然后线程各自进行了初始化。

`复合操作`

假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么B全部执行完，要么完全不执行B，那么A和B对彼此来说就是院子的。

原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。

![线程安全的计数器](https://tva1.sinaimg.cn/large/005VwC5mly1g86yxk4ysqj30uv0arq56.jpg)

在这里，将普通的计数改为了一个线程安全的计数器，AtomicLong 是一个线程安全类，由于`Servlet`的状态就是计数器的状态，并且计数器是线程安全的，因此这里的`Servlet`也是线程安全的。

## 加锁机制
要保持状态的一致性，就需要再单个原子操作中更新所有相关的状态变量。

`内置锁`

Java提供了一种内置的锁机制来支持原子性：同步代码块。

同步代码块包括两部分：一个作为锁的对象引用，一个作为

内置锁是一个互斥锁，最多只有一个线程能持有这种锁，当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或阻塞，直到线程B释放这个锁。如果B永远不释放锁，那么A也将永远的等下去。

但是添加了内置锁的代码块，并发性也变得比较插件。

`重入`

如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的细粒度是“线程”而不是“调用”。

![可重入锁](https://tvax4.sinaimg.cn/large/005VwC5mly1g870fbdc7aj310q0cotar.jpg)

最开始看到这个代码，还有点感觉很奇怪。。。。但是后来想了想，是自己陷入了思维误区。

其实应该说是，在这里，如果调用子类的`doSomething()`方法的时候，会首先获取子类当前方法的锁，然后当调用`super.doSomething()`的时候，会去获取父类的锁，我以为是会真的去获取父类的锁，其实不然，继承是一个抽象的概念，其实始终都只有子类这个一个锁存在，获取父类的锁，其实这个父类也应该就是自己，在这里只是一个概念上的父类，并不是有一个真正的父类对象，让你去获取他的锁。

如果有在父类中再添加一个同步方法（方法内最好睡眠5秒），在子类中新增加非同步方法，然后去调用这个同步方法，在测试类中，起两个线程，第一个线程调用子类的非同步方法，且等待1秒之后，第二个线程去调用`doSomething()`这个方法，你就会发现，发生了等待，而且是在子类方法执行前就要等待线程A释放父类的锁。

讲了这么一段，其实核心的就是，这里有个误区，父类的锁其实就是子类的锁。换句换说，其实应该把代码都放到一个类中去看，而不是用继承体系去区分父类子类，因为继承关系就是合并成了一个类。

## 用锁来保护状态
由于锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的的独占访问。

对于可能的被多个线程同时访问的可变状态变量，在访问它适都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。

并非所有的数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。

## 活跃性与性能

不良并发应用程序：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制

通常，在简单性与性能之间存在这互相制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能会破会安全性）。

当执行时间较长的计算或者可能无法快速完成的操作时候，一定不要持有锁。

## 总结
这章节主要介绍了线程安全的概念，加锁的机制，可重入锁，对象状态等基本信息，因式分解的那个代码，看的还是很懵逼得。。。。

这章总的来说主要是介绍了一些概念。
