# 2.线程安全性
“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。

一个对象是否需要是线程安全的，取决于它是否被多个线程访问。

当多个线程访问某个状态变量并且其中一个线程执行写入操作时，必须采用用同步机制来协同这些线程对变量的访问。

Java中的主要同步机制是关键字`synchronized`，它提供了一种独占锁的加锁方式，但“同步”这个属于还包括`volatile`类型的变量，显式锁以及原子变量。


如果当多个线程访问同一个可变的`状态变量`时，没有使用合适的同步，那么程序就会可能出现错误。有三种方式可以修复这个问题：
1. 不再线程间共享该状态变量
2. 将该状态变量修改为不可变的变量
3. 在访问状态变量时使用同步

当设计线程安全的类时，良好的面向对象技术、不可修改性，以及明晰的不可变性规范都能起到一定帮助作用。

## 什么是线程安全性
在线程安全性的定义中，最核心的概念就是正确性：`某个类与其规范完全一致。`

当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类时线程安全的。

>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要额外的同步或协同，这个类都能表现出正常的行为，那么就称这个类时线程安全的。

如果正确地实现了某个对象，那么在任何操作中（包括调用对象的公有方法或者对其公有域进行读/写操作）都不会违背不变性条件或后验条件。

在线程安全类的对象实例上执行的任何串行或并行操作都不会使对象处于无效状态。

![不变性与后验条件](https://tva3.sinaimg.cn/large/005VwC5mly1g865wzujvaj30pa061tdh.jpg)

无状态的：
>既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。

`无状态对象一定是线程安全的`

大多数的`Servlet`都是无状态的，从而极大地降低了在实现`Servlet`线程安全性时的复杂性。

## 原子性
代码：

![计数器示例](https://tva3.sinaimg.cn/large/005VwC5mly1g866beqfnoj30lb07r75a.jpg)

`++value`包含了三个操作：`读取-修改-写入`的操作序列，并且其结果状态依赖于之前的状态。

如果该计数器被用来生成数值被用来生成数值序列或者唯一的对象标识符，那么多次调用中返回相同值将会导致严重的数据完整性问题，在并发编程中，这种由于不恰当执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞争条件。

最常见的竞争条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作。
