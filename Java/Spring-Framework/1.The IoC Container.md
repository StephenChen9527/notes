# 1.The Ioc Container

这里主要是讲解了一些基础的spring相关容器、bean、控制反转、依赖注入等相关知识。

包括XML、注解等配置。


## 1.1、Introduction to the Spring IoC Container and Beans

控制反转（IoC），也称为依赖注入（DI）。

ApplicationContext是BeanFactory的一个子类，主要增加了以下几点功能：
* 与Spirng AOP功能轻松集成
* 消息资源处理
* 事件发布
* 特定用于Web程序的上下文，ApplicationContext



Context主要有以下几种主要实现：
* FileSystemXmlApplicationContext 基于文件系统的XML上下文（可以写绝对路径）
* ClassPathXmlApplicationContext  基于类路径的XML上下文（相对路径）
* AnnotationConfigApplicationContext  基于注解的上下文（Spring Boot 应该就是从这里开始加载的）
* WebApplicationContext （用于Web程序，在Spring Web中）


## 1.2. Container Overview 容器概述

`org.springframework.context.ApplicationContext`接口代表Spring IoC容器，并负责实例化、配置和组装Bean。

配置方式：
1. XML配置文件
2. Java注解
3. Java代码

Spring工作原理视图：

![Spring工作原理视图](https://tva3.sinaimg.cn/large/005VwC5mly1g9zqhjwtmyj30hb0al74t.jpg)

#### 配置元数据

1. XML最开始就支持
2. 基于注解的配置：Spring 2.5 （@Compoent）
3. 基于Java的配置：Spring 3.0  （@Configuration）

`https://blog.csdn.net/majishushu/article/details/53587902`

三种配置方式的异同，其实Java Config就是基于注解的升级，不用将各种配置放到分散的类上，而是统一写在一个类中（java配置类）通过方法上添加@bean 注解，标识。

Spring配置容器管理至少一个，基于XML的配置需要将bean放在<beans></beans>元素中，Java config的方式则需要统一放在具有@Configuration中

标准XML：
```XML
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <bean id="..." class="...">
        <!-- collaborators and configuration for this bean go here -->
    </bean>

    <!-- more bean definitions go here -->

</beans>
```

#### 实例化容器

1. XML：ClassPathXmlApplicationContext与FileSystemXmlApplicationContext

可以加载多个XML配置文件，多个XML配置文件可以分为并列和包含的关系。

`https://www.cnblogs.com/thegarden/p/11827252.html`

并列则为一次性加载多个XML，并列则为加载一个，这个配置文件又使用了import包含其他的XML。

```XML
<beans>
    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>
    <!-- messageSource 与themeSource 位置一样，与themeSource的第一个斜杠会被忽略  -->
    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>
</beans>
```

但是应该有个父容器。。。如果是一次加载多个，这个父容器是谁？

2. 注解与Java Config

#### 使用容器

`ApplicationContext`是一个维护bean定义以及相互依赖的注册表的高级工厂的接口。

`T getBean(Class requireType)`

但是尽量不要使用此方法，最好使用自动注入。

## 1.3. Bean Overview

IoC容器可以管理多个bean，在容器内，这些bean定义表示为`BeanDefinition`对象，主要有以下元数据：
* 类的完全限定名
* 行为配置（scop、生命周期）
* 引用依赖
* 连接数？

XML中配置的各种属性：

|            属性            |            释义            |
|:--------------------------:|:--------------------------:|
|          `Class`           |         完全限定名         |
|           `Name`           |         bean的名称         |
|           `Scop`           |  bean的范围（单例、多例）  |
|  `Constructor arguments`   |          依赖注入          |
|        `Properties`        |          依赖注入          |
|     `Autowiring mode`      | 自动装配（byName、byType） |
| `Lazy initialization mode` |           懒加载           |
|  `Initialization method`   |         初始化方法         |
|    `Destruction method`    |          销毁方法          |

 Spring文档翻译有个搞笑的地方：

![翻译](https://tvax2.sinaimg.cn/large/005VwC5mly1g9ztabhse6j311l09dq4i.jpg)

我以为可以通过ApplicationContext获取BeanFactory，然后注册一个没有配置过的bean。。

原来翻译翻的有问题，理解错了，大概这段话说的，就是调用getBean的时候，内部的调用关系是这么一回事。。。。

看下面，非延迟加载的好处就是启动时可以碰到问题，而不必等到运行时。运行时也不支持注册新bean。

#### 命名bean
>每个bean具有一个或多个标识符。这些标识符在承载Bean的容器内必须是唯一的。一个bean通常只有一个标识符。但是，如果需要多个，则可以将多余的别名视为别名。

XML配置文件中可以使用id去唯一标识一个bean，name可以作为别名存在，一个bean只有一个name，但是可以有多个别名。

```XML
<bean class="com.nullbugs.web.bean.TestName" id="testName" name="testName2 testName3"></bean>
<alias name="testName" alias="testName4"></alias>
```
name可以逗号，分号，空格，隔开，alias也是别名。

约定：bean名称以小写字母开头，并从那里用驼峰式大小写。

#### 实例化bean


## 1.4. Dependencies

## 1.5. Bean Scopes

## 1.6. Customizing the Nature of a Bean

### 1.6.1 Lifecycle Callbacks
#### Initialization Callbacks
#### Combining Lifecycle Mechanisms
#### Default Initialization and Destroy Methods
```java
@PostConstruct
@PreDestroy
```
这两个是JAE原生注解，第一个注解在属性初始化后（应该），进行回调。

第二个注解在销毁前进行回调。

如果不想使用JRE自带，在spring中可以实现
```java
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.DisposableBean;

void afterPropertiesSet() throw Exception;
void destroy() throw Exception;
```


在XML中的使用为：
```java
<bean id="ex" class="com.ex1.ex" init-method="init"/>
```
销毁在XML中为：
```java
<bean id="ex" class="com.ex1.ex" destroy-method="destroy"/>
```
推荐使用JRE注解，这样子，是没有耦合到Spring框架中的。

在XML中，如果将根元素属性设置出来，则没个容器都会自动的调用其初始化、销毁方法。
```java
<beans default-init-method="" default-destroy-method="">
</beans>
```
如果XML中的bean元素也设置了
```java
init-method
destroy-method
```
两个属性，则覆盖。


实测当同时使用(初始化回调与销毁回调)JRE注解，与实现spring方法的时候实际的运行先后顺序为：

* 静态方法
* 构造器
* JRE注解
* Spring接口实现的方法
* 自定义的方法

官方DOC中也有标明


####Startup and Shutdown Callbacks
```java
import org.springframework.context.Lifecycle;

public interface Lifecycle{
  void start();
  void stop();
  boolean isRunning();
}

import org.springframework.context.LifecycleProcessor;

public interface LifecycleProcessor extends Lifecycle{
  void onRefresh();
  void onClose();
}
```

在spring管理的对象中，都能实现Lifecycle接口，当ApplicationContext接收到开始或者停止的信号的时候，会进行调用这些实现接口的类。

ps：LifecycleProcessor 是 Lifecycle 的增强类，看完doc觉得自己还没有使用到的情景，baidu之后发现一个不错的blog，从源码部分进行解析、总结。

先进行记录，尔后在进行详细的品读。
> https://blog.csdn.net/boling_cavalry/article/details/82051356

#### Shutting Down the Spring IoC Container Gracefully in Non-Web Applications
主要说明了在非web应用程序，关闭IoC容器。
```java
-
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

        // add a shutdown hook for the above context...
        ctx.registerShutdownHook();

        // app runs here...

        // main method exits, hook is called prior to the app shutting down...
    }
}
```
### 1.6.2 ApplicationContextAware and BeanNameAware
这部分内容主要讲各种Aware接口，在我之前的使用看来，应该是实现某Aware接口，可以获取某能力。
* ApplicationContextAware

此接口可以注入ApplicationContenxt，并且转换为已知子类，进行使用，在gfms中看到使用，用来获取IoC容器中的bean实例。
在Spring2.5 之后，可以直接使用 @Autowired 注解进行注入，方便解耦。
* BeanNameAware

实现此接口之后，在初始化之后会进行回调方法
```java
void setBeanName(String name) throw BeansException;
```

在本方法回调之前，还有 初始化的那些方法进行执行。
### 1.6.3 Other Aware Interfaces
不介绍，因为实现了这些接口，就会导致入侵，因此需要的话，就使用自动注入就行了。

## 1.7. Bean Definition Inheritance

在XML配置中：
```java
<bean id="inheritedTestBean" abstract="true"
        class="org.springframework.beans.TestBean">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithDifferentClass"
        class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBean" init-method="initialize">
    <property name="name" value="override"/>
    <!-- the age property value of 1 will be inherited from parent -->
</bean>
```
这种配置是说 第一个class是一个父类。 这些属性

第二个class子类，子类可以继承父类的属性，也可以重写父类的属性。
主要是parent属性，父类中的 abstract 代表是一个 抽象类。

在子类中的  parent 属性，可以继承父类的值。

## 1.8. Container Extension Points

#### 1.8.1. Customizing Beans by Using a BeanPostProcessor
Spring bean 的后置处理器。
```java
import   org.springframework.beans.factory.config.BeanPostProcessor;

public Object  postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;

```
这是这个类的两个方法，第一个方法为 初始化之前进行，比@PostConstruct早，第二个方法为初始化之后进行，要比Spring接口InitializingBean 中的afterPropertiesSet 方法慢一点。

这个接口主要是在Bean实例化前后做一些处理，可以定制多个处理器，使用`@Order`，或者实现Ordered 接口进行排序。

Spring AOP为后置处理器。



## 1.9. Annotation-based Container Configuration
