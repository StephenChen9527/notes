### 简单的HTTP协议
##### 2.1 HTTP协议用于客户端和服务端之间的通信
HTTP协议和TCP/IP协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。

请求访问文本或者图像等资源的一端为客户端（发起请求端），提供资源响应的一端称为服务器端（处理请求端）。

##### 2.2通过请求和响应的交换达成通信

![HTTP请求头](https://wx3.sinaimg.cn/large/005VwC5mly1g6pvpcluqfj30ty0523ym.jpg)

* 第一行`GET`表示请求服务器类型，称为方法。
* 后面的`/`指明请求资源对象
* `HTTP/1.1`表示HTTP请求的版本号

其他信息暂时不说明。

请求报文是由请求方法、请求URI、协议版本、可选的请求手部字段和内容实体构成的。

![请求报文头](https://ws3.sinaimg.cn/large/005VwC5mly1g6pvu5vk87j30q90c9jwb.jpg)

服务器接收到请求之后，会对其进行响应，响应基本会包括以下几部分：
![响应报文头](https://wx3.sinaimg.cn/large/005VwC5mly1g6pvzgbzsgj30pa0783yz.jpg)

响应报文头也很简单，HTTP版本。

`200 OK`表示处理结果的状态码和原因短语，`Date`表示日期，`Content-Length`表示返回数据的长度，`Content-Type`表示返回的类型。

![响应](https://wx3.sinaimg.cn/large/005VwC5mly1g6pw4qg55jj30p00bftcn.jpg)

##### 2.3HTTP是不保存状态的协议
HTTP是一种无状态协议，也就是说在HTTP这个级别，协议对于发送过的请求和处理过的响应都不做持久化处理。

HTTP为了实现保持状态，引入了`Cookie`技术。

##### 2.4请求URI定位资源符
| OPTIONS * HTTP/1.1 |
|:------------------:|

这种方法是查询HTTP服务器支持HTTP方法种类。（不太会使用）

![postman模拟OPTIONS](https://ws4.sinaimg.cn/large/005VwC5mly1g6pxg18odaj312e0i5gn0.jpg)


##### 2.5告知服务器意图的HTTP方法

* `GET`：获取资源。指定的资源服务器端解析后返回响应内容。
* `POST`：传输实体主体（参数）。`GET`方法也可以传输，但是一般使用POST方法进行传输。
* `PUT`：传输文件。就想`FTP`协议的文件上传一样，要求在报文的主体中包含文件内容，然后保存到`URI`指定的位置。但是`HTTP/1.1`的`PUT`方法自身不带验证机制，一般会禁用。
* `HEAD`：获取报文首部。和`GET`类似，但是不返回报文主体。
* `DELETE`：删除文件，与`PUT`相反。
* `OPTIONS`：询问支持的方法。
* `TRACE`：追踪路径。`TRACE`方法是让Web服务器端将之前的请求通信环回给客户端的方法。（Linux中可以追踪到请求变化，用的就是这个？）

![TRACE](https://wx4.sinaimg.cn/large/005VwC5mly1g6pxlpxmg4j30qm0cnn3p.jpg)

![TRACE请求图例](https://ws4.sinaimg.cn/large/005VwC5mly1g6pxma5bfaj30qi0a0gtv.jpg)
* `CONNECT`：要求用隧道协议连接代理，实现用隧道协议进行`TCP`通信。主要使用`SSL(安全套接字)`和`TLS(传输层安全)`协议进行加密。

这么多方法，我们常用的就`GET`、`POST`.......

##### 2.6使用方法下达命令
请求URI指定资源的时候，采用称为方法的`命令`。

HTTP版本方法支持表：

|   方法    |          说明          | 支持的HTTP协议版本 |
|:---------:|:----------------------:|:------------------:|
|   `GET`   |        获取资源        |      1.0/1.1       |
|  `POST`   |      传输消息主体      |      1.0/1.1       |
|   `PUT`   |        传输文件        |      1.0/1.1       |
|  `HEAD`   |      获得报文首部      |      1.0/1.1       |
| `DELETE`  |        删除文件        |      1.0/1.1       |
| `OPTIONS` |     询问支持的方法     |        1.1         |
|  `TRACE`  |        追踪路径        |        1.1         |
| `CONNECT` | 要求用隧道协议连接代理 |        1.1         |
|  `LINK`   |  建立和资源之间的联系  |        1.0         |
| `UNLINE`  |      断开连接关系      |        1.0         |

##### 2.7持久连接节省通信量
HTTP协议的初始版本中，每进行一次HTTP通信就要重新建立、断开一次TCP连接。

但是现在随着一个页面需要访问的资源更多:`IMG`、`JS`、`CSS`等文件，每次都需要经过三次握手建立连接，造成了无畏的TCP连接建立和断开，增加通信量的开销。

###### 持久连接
HTTP/1.1 增加了持久连接（长连接），只有任意一端没有明确提出断开连接，则保持TCP连接状态。

PS：之前一直认为是“`HTTP`请求建立了`三次握手`，长连接是保持了`HTTP`的状态”。

纠正：是因为每一次的`HTTP`请求，都要建立`TCP`连接，通信完之后，再进行断开，导致每次`HTTP`请求都需要重新建立`TCP`连接。且明白`HTTP`仅仅是一种协议而已，并不是它去建立的连接，建立连接的是`TCP`协议。一次`TCP`通信可以有多个`HTTP`请求，是因为`TCP`去保持了连接，没有断开而已，而不是`HTTP`没有断开，`HTTP`是无状态的，一个通信来回使用一次`HTTP`。

![一次TCP多次HTTP](https://wx4.sinaimg.cn/large/005VwC5mly1g6pymcink3j30p90kcqcq.jpg)

`HTTP/1.1`中，所有默认的都是持久连接，这样的好处是减少了`TCP`在建立连接的时候，三次握手、四次挥手所造成的重复性浪费。

###### 管线化
之前发送请求后，需要等待并接受响应，才能发送下一个请求（同步？）
有了长连接，可以同时发送多个请求（异步？）。

一言蔽之，长连接导致了管线化请求方式的实现，管线化请求方式即为：可以同时发送多个请求，无需等待请求结束后，在进行下次请求。

##### 2.8Cookie的状态管理
`HTTP`是一个无状态协议，不会对之前发生过的请求和响应进行管理，因此采用了`Cookie`技术，既能保留无状态协议特征，又能解决区分用户的矛盾。

`Cookie`会根据从服务端发送的响应报文内的一个叫`Set-Cookie`的首部字段信息，通知客户端保存`Cookie`，下次再发送请求的时候，客户端会自动在请求报文中加入`Cookie`值后再进行发送。

![Cookie](https://wx2.sinaimg.cn/large/005VwC5mly1g6ug37s6f4j30pl0juwi5.jpg)
